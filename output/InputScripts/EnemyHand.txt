class_name EnemyHand
extends Node2D

const CARD_WIDTH:int = 110
const HAND_Y_POSITION:int = -30
const DEFAULT_CARD_MOVE_SPEED:float = 0.8

# Fixed area constants
const HAND_START_X:int = 340
const HAND_WIDTH:int = 630

var player_hand:Array = []
var center_screen_x:float

func _ready() -> void:
	center_screen_x = get_viewport().size.x/2

func add_card_to_hand(card, speed) -> void:
	if card not in player_hand:
		player_hand.append(card)
		update_hand_positions(speed)
		card.state_machine.transition_to(card.state_machine.State.IN_HAND, GameConstants.TriggerSource.GAME_RULE)
	else:
		animate_card_to_position(card, card.hand_position, DEFAULT_CARD_MOVE_SPEED)

func update_hand_positions(speed) -> void:
	for i in range(player_hand.size()):
		var new_position:Vector2 = Vector2(calculate_card_position(i), HAND_Y_POSITION)
		var card = player_hand[i]
		card.position = new_position
		animate_card_to_position(card, new_position, speed)

func calculate_card_position(index) -> float:
	var card_count = player_hand.size()
	
	# For centering a single card
	if card_count == 1:
		return HAND_START_X + (HAND_WIDTH / 2.0) - (CARD_WIDTH / 2.0)
	
	# Calculate total width needed if cards were placed side by side
	var total_width_needed = card_count * CARD_WIDTH
	
	# If we have enough space, center the cards with minimal spacing
	if total_width_needed <= HAND_WIDTH:
		# Center the cards in the available space
		var start_x = HAND_START_X + (HAND_WIDTH - total_width_needed) / 2.0
		return start_x + (index * CARD_WIDTH)
	else:
		# Not enough space, we need to overlap cards
		# Calculate overlap required to fit all cards in the available width
		var overlap_per_card = (total_width_needed - HAND_WIDTH) / float(card_count - 1)
		var effective_card_width = CARD_WIDTH - overlap_per_card
		
		# Calculate position with overlap
		var start_x = HAND_START_X
		return start_x + (index * effective_card_width)

func animate_card_to_position(card, new_position, speed) -> void:
	# Create a new tween for this animation
	var tween: Tween = get_tree().create_tween()
	# Tween directly to the target position (both X and Y simultaneously)
	tween.tween_property(card, "position", new_position, speed)

func remove_card_from_hand(card) -> void:
	if card in player_hand:
		player_hand.erase(card)
		update_hand_positions(DEFAULT_CARD_MOVE_SPEED)
		
		
func get_card_nodes_in_hand() -> Array[BaseCard]: # Type hint if EnemyCard extends BaseCard
	var card_nodes: Array[BaseCard] = []
	for card_node_untyped in player_hand: # 'player_hand' is your internal array
		if card_node_untyped is BaseCard:
			card_nodes.append(card_node_untyped as BaseCard)
	return card_nodes
